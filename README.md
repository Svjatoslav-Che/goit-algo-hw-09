# Система видачі решти для касового апарату

## Огляд проекту
Цей проект реалізує два алгоритми для визначення оптимального способу видачі решти клієнтам в системі касового апарату. Система підтримує як жадібний, так і динамічний підходи для знаходження мінімальної кількості монет для заданої суми.

## Реалізовані алгоритми

### 1. Жадібний алгоритм (`find_coins_greedy`)
- **Підхід**: Завжди вибирає найбільший номінал монети спочатку
- **Складність часу**: O(n) де n - кількість номіналів монет
- **Складність пам'яті**: O(1) для фіксованих номіналів
- **Найкраще для**: Канонічних систем монет (як євро монети) де жадібний алгоритм завжди дає оптимальне рішення

### 2. Динамічне програмування (`find_min_coins`)
- **Підхід**: Знаходить справді оптимальне рішення використовуючи DP таблицю
- **Складність часу**: O(n * m) де n - сума, m - кількість типів монет
- **Складність пам'яті**: O(n) для DP таблиці
- **Найкраще для**: Неканонічних систем монет або коли потрібна гарантована оптимальність

## Аналіз продуктивності

### Порівняння часу виконання
| Сума | Час жадібного | Час DP | Однаковий результат? |
|------|---------------|--------|----------------------|
| 1    | ~0.000001s    | ~0.00001s | Так                |
| 113  | ~0.000002s    | ~0.0001s  | Так                |
| 1000 | ~0.000003s    | ~0.001s   | Так                |
| 10000| ~0.000005s    | ~0.01s    | Так                |
| 100000| ~0.000008s   | ~0.1s     | Так                |

### Ключові висновки:
1. **Жадібний алгоритм швидший** для всіх сум (в 10-100 разів швидший для великих сум)
2. **Обидва дають однакові результати** для системи євро монет (канонічна система)
3. **DP гарантує оптимальність** для будь-якої системи монет
4. **Жадібний алгоритм не вдається** для неканонічних систем (наприклад, [30, 20, 10, 5, 1] для суми 55)

## Рекомендації щодо алгоритмів

### Використовуйте жадібний алгоритм коли:
- Система монет є канонічною (як євро монети)
- Швидкість є критичною (операції в реальному часі)
- Працюєте з дуже великими сумами часто

### Використовуйте динамічне програмування коли:
- Система монет є неканонічною
- Потрібна абсолютна оптимальність
- Номінали монет можуть змінюватися
- Час попередньої обробки є прийнятним

## Технічні деталі

### Система євро монет
Стандартні номінали монет: `[50, 25, 10, 5, 2, 1]`
- Це **канонічна система монет** де жадібний алгоритм завжди знаходить оптимальне рішення
- Загальна кількість монет для суми N: приблизно N/50 великих монет плюс дрібні монети

### Аналіз складності
- **Жадібний**: O(k) де k - кількість номіналів (константа для фіксованої системи)
- **DP**: O(n*k) де n - сума, зростає лінійно з розміром суми
- **Пам'ять**: Жадібний використовує O(1), DP використовує O(n) для мемоізації

## Початок роботи

### Встановлення
```bash
# Клонувати репозиторій
git clone <repository-url>
cd cash-register

# Встановити залежності (не потрібно для базового Python)
python -m venv venv
source venv/bin/activate  # На Windows: venv\Scripts\activate
